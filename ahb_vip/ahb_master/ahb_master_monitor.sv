////----------------------------------------------------------------------
//// This file has been automatically generated by
//// VerifStudio Software Version 0.63, Accelver Systems Inc.
//// Any modifications that you make to this file may be
//// overwritten by the tool when regenerating the files. 
////----------------------------------------------------------------------

`ifndef AHB_MASTER_MONITOR__SV
`define AHB_MASTER_MONITOR__SV

class ahb_master_monitor #(
    AHB_ADDR_WIDTH = 16,
    AHB_DATA_WIDTH = 16
) extends uvm_monitor;

  // variables for the run phase
  ahb_states state;



  // Declare a handle to the configdb object associated with this agent.
  ahb_master_config #(AHB_ADDR_WIDTH, AHB_DATA_WIDTH) config_db;

  // Declare a handle to the Virtual Interface
  virtual ahb_interface #(AHB_ADDR_WIDTH, AHB_DATA_WIDTH) vif;

  // Register the class ahb_master_monitor with the factory.
  `uvm_component_param_utils(ahb_master_monitor#(AHB_ADDR_WIDTH, AHB_DATA_WIDTH))

  ahb_master_transaction #(AHB_ADDR_WIDTH, AHB_DATA_WIDTH) req;

  // The Constructor for this Class.
  function new(string name = "ahb_master_monitor", uvm_component parent);
    super.new(name, parent);
  endfunction : new

  // Declare the build phase of the UVM Monitor.
  extern virtual function void build_phase(uvm_phase phase);

  // Declare the connect phase of the UVM Monitor.
  extern virtual function void connect_phase(uvm_phase phase);

  // Declare the run phase of the UVM Monitor.
  extern task run_phase(uvm_phase phase);

endclass : ahb_master_monitor


// Define the build phase of the UVM Monitor.
function void ahb_master_monitor::build_phase(uvm_phase phase);

  super.build_phase(phase);

  `uvm_info(get_type_name(), "Inside the Build Phase of ahb_master_monitor.", UVM_HIGH)

  // Get the config_object from the uvm_config_db.
  if (!uvm_config_db#(ahb_master_config#(AHB_ADDR_WIDTH, AHB_DATA_WIDTH))::get(
          this, "", "master_config_object", config_db
      )) begin
    `uvm_fatal(get_type_name(), "The Configuration Object for the monitor has not been set.")
  end

endfunction : build_phase


// Define the connect phase of the UVM Monitor.
function void ahb_master_monitor::connect_phase(uvm_phase phase);

  super.connect_phase(phase);

  `uvm_info(get_type_name(), "Inside the Connect Phase of ahb_master_monitor.", UVM_HIGH)

  vif = config_db.vif;

endfunction : connect_phase


// Define the run phase of the UVM Monitor.
task ahb_master_monitor::run_phase(uvm_phase phase);

  super.run_phase(phase);

  `uvm_info(get_type_name(), "Inside the Run Phase of ahb_master_monitor.", UVM_HIGH)

  // Please put your logic here....
  // Transaction object to store the states of the SIGNALS

  req   = ahb_master_transaction#(AHB_ADDR_WIDTH, AHB_DATA_WIDTH)::type_id::create("req", this);
  state = s_IDLE;

  forever begin

    @(posedge vif.HCLK)

    case (state)

      s_IDLE: begin
        if (vif.HTRANS == AHB_IDLE) begin
          state = s_IDLE;
        end 

				else begin
          state = s_ADDR;
        end
      end

      s_ADDR: begin
        req.m_address <= vif.HADDR;//TODO: need to figure if we should put data to analysis port if not what to compare it with
        forever begin
          @(posedge vif.HCLK)
          if (vif.HREADY == AHB_READY ) begin
            state = vif.HWRITE ? s_WRITE : s_READ;
            break;
          end
        end
      end

      s_READY_CHECK: begin

        forever begin
        
					@(posedge vif.HCLK)
          
					if (vif.HREADY == AHB_READY) begin
            // since we are only writing for NONSEQ 
            // state = s_ADDR;
					
						if (vif.HTRANS == AHB_IDLE) begin
							state = s_IDLE ;
						end

						else if (vif.HWRITE == AHB_READ) begin
							state = s_READ;
						end
						
						else if (vif.HWRITE == AHB_WRITE) begin
							state = s_WRITE ;
						end
            
						break;
          
					end
        end
      end

      s_WRITE: begin
        req.m_wdata = vif.HWDATA;
        state = s_READY_CHECK;
      end

      s_READ: begin
        req.m_rdata = vif.HRDATA;  // TODO: need to figure out how to get rdata
        state = s_READY_CHECK;
      end

    endcase
  end

endtask : run_phase

`endif
